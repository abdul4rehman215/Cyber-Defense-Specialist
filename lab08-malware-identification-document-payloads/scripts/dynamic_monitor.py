#!/usr/bin/env python3

import os
import sys
import time
import psutil
import json
import subprocess
from datetime import datetime


class DynamicMonitor:

    def __init__(self):
        self.baseline = []
        self.changes = {
            "new_processes": [],
            "network_connections": []
        }

    def get_process_baseline(self):

        processes = []

        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                processes.append({
                    "pid": proc.info['pid'],
                    "name": proc.info['name'],
                    "cmdline": proc.info['cmdline']
                })
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

        return processes

    def monitor_processes(self):

        current = self.get_process_baseline()

        baseline_pids = {p['pid'] for p in self.baseline}

        for proc in current:
            if proc['pid'] not in baseline_pids:
                self.changes['new_processes'].append(proc)

    def monitor_network(self):

        connections = psutil.net_connections()

        for conn in connections:
            if conn.status == "ESTABLISHED":
                self.changes['network_connections'].append({
                    "laddr": str(conn.laddr),
                    "raddr": str(conn.raddr),
                    "pid": conn.pid
                })

    def start_monitoring(self, command, duration=30):

        self.baseline = self.get_process_baseline()

        process = subprocess.Popen(command, shell=True)

        start_time = time.time()

        while time.time() - start_time < duration:
            self.monitor_processes()
            self.monitor_network()
            time.sleep(2)

        process.wait()

    def generate_report(self):

        report = {
            "timestamp": datetime.now().isoformat(),
            "baseline_process_count": len(self.baseline),
            "changes": self.changes
        }

        output_file = os.path.expanduser(
            f"~/malware_analysis/results/dynamic_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        )

        with open(output_file, "w") as f:
            json.dump(report, f, indent=4)

        return report


def main():

    if len(sys.argv) != 3:
        print('Usage: python3 dynamic_monitor.py "<command>" <duration>')
        sys.exit(1)

    command = sys.argv[1]
    duration = int(sys.argv[2])

    monitor = DynamicMonitor()
    monitor.start_monitoring(command, duration)

    report = monitor.generate_report()

    print(json.dumps(report, indent=4))


if __name__ == "__main__":
    main()
